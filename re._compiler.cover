       #
       # Secret Labs' Regular Expression Engine
       #
       # convert template to internal format
       #
       # Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.
       #
       # See the __init__.py file for information on usage and redistribution.
       #
       
>>>>>> """Internal support module for sre"""
       
>>>>>> import _sre
>>>>>> from . import _parser
>>>>>> from ._constants import *
>>>>>> from ._casefix import _EXTRA_CASES
       
>>>>>> assert _sre.MAGIC == MAGIC, "SRE module mismatch"
       
>>>>>> _LITERAL_CODES = {LITERAL, NOT_LITERAL}
>>>>>> _SUCCESS_CODES = {SUCCESS, FAILURE}
>>>>>> _ASSERT_CODES = {ASSERT, ASSERT_NOT}
>>>>>> _UNIT_CODES = _LITERAL_CODES | {ANY, IN}
       
>>>>>> _REPEATING_CODES = {
>>>>>>     MIN_REPEAT: (REPEAT, MIN_UNTIL, MIN_REPEAT_ONE),
>>>>>>     MAX_REPEAT: (REPEAT, MAX_UNTIL, REPEAT_ONE),
>>>>>>     POSSESSIVE_REPEAT: (POSSESSIVE_REPEAT, SUCCESS, POSSESSIVE_REPEAT_ONE),
       }
       
>>>>>> def _combine_flags(flags, add_flags, del_flags,
>>>>>>                    TYPE_FLAGS=_parser.TYPE_FLAGS):
   38:     if add_flags & TYPE_FLAGS:
    2:         flags &= ~TYPE_FLAGS
   38:     return (flags | add_flags) & ~del_flags
       
>>>>>> def _compile(code, pattern, flags):
           # internal: compile a (sub)pattern
  113:     emit = code.append
  113:     _len = len
  113:     LITERAL_CODES = _LITERAL_CODES
  113:     REPEATING_CODES = _REPEATING_CODES
  113:     SUCCESS_CODES = _SUCCESS_CODES
  113:     ASSERT_CODES = _ASSERT_CODES
  113:     iscased = None
  113:     tolower = None
  113:     fixes = None
  113:     if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:
   49:         if flags & SRE_FLAG_UNICODE:
   45:             iscased = _sre.unicode_iscased
   45:             tolower = _sre.unicode_tolower
   45:             fixes = _EXTRA_CASES
               else:
    4:             iscased = _sre.ascii_iscased
    4:             tolower = _sre.ascii_tolower
  288:     for op, av in pattern:
  175:         if op in LITERAL_CODES:
   35:             if not flags & SRE_FLAG_IGNORECASE:
   18:                 emit(op)
   18:                 emit(av)
   17:             elif flags & SRE_FLAG_LOCALE:
>>>>>>                 emit(OP_LOCALE_IGNORE[op])
>>>>>>                 emit(av)
   17:             elif not iscased(av):
   17:                 emit(op)
   17:                 emit(av)
                   else:
>>>>>>                 lo = tolower(av)
>>>>>>                 if not fixes:  # ascii
>>>>>>                     emit(OP_IGNORE[op])
>>>>>>                     emit(lo)
>>>>>>                 elif lo not in fixes:
>>>>>>                     emit(OP_UNICODE_IGNORE[op])
>>>>>>                     emit(lo)
                       else:
>>>>>>                     emit(IN_UNI_IGNORE)
>>>>>>                     skip = _len(code); emit(0)
>>>>>>                     if op is NOT_LITERAL:
>>>>>>                         emit(NEGATE)
>>>>>>                     for k in (lo,) + fixes[lo]:
>>>>>>                         emit(LITERAL)
>>>>>>                         emit(k)
>>>>>>                     emit(FAILURE)
>>>>>>                     code[skip] = _len(code) - skip
  140:         elif op is IN:
   41:             charset, hascased = _optimize_charset(av, iscased, tolower, fixes)
   41:             if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
>>>>>>                 emit(IN_LOC_IGNORE)
   41:             elif not hascased:
   35:                 emit(IN)
    6:             elif not fixes:  # ascii
    4:                 emit(IN_IGNORE)
                   else:
    2:                 emit(IN_UNI_IGNORE)
   41:             skip = _len(code); emit(0)
   41:             _compile_charset(charset, flags, code)
   41:             code[skip] = _len(code) - skip
   99:         elif op is ANY:
    3:             if flags & SRE_FLAG_DOTALL:
    2:                 emit(ANY_ALL)
                   else:
    1:                 emit(ANY)
   96:         elif op in REPEATING_CODES:
   45:             if _simple(av[2]):
   33:                 emit(REPEATING_CODES[op][2])
   33:                 skip = _len(code); emit(0)
   33:                 emit(av[0])
   33:                 emit(av[1])
   33:                 _compile(code, av[2], flags)
   33:                 emit(SUCCESS)
   33:                 code[skip] = _len(code) - skip
                   else:
   12:                 emit(REPEATING_CODES[op][0])
   12:                 skip = _len(code); emit(0)
   12:                 emit(av[0])
   12:                 emit(av[1])
   12:                 _compile(code, av[2], flags)
   12:                 code[skip] = _len(code) - skip
   12:                 emit(REPEATING_CODES[op][1])
   51:         elif op is SUBPATTERN:
   31:             group, add_flags, del_flags, p = av
   31:             if group:
   28:                 emit(MARK)
   28:                 emit((group-1)*2)
                   # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))
   31:             _compile(code, p, _combine_flags(flags, add_flags, del_flags))
   31:             if group:
   28:                 emit(MARK)
   28:                 emit((group-1)*2+1)
   20:         elif op is ATOMIC_GROUP:
                   # Atomic Groups are handled by starting with an Atomic
                   # Group op code, then putting in the atomic group pattern
                   # and finally a success op code to tell any repeat
                   # operations within the Atomic Group to stop eating and
                   # pop their stack if they reach it
>>>>>>             emit(ATOMIC_GROUP)
>>>>>>             skip = _len(code); emit(0)
>>>>>>             _compile(code, av, flags)
>>>>>>             emit(SUCCESS)
>>>>>>             code[skip] = _len(code) - skip
   20:         elif op in SUCCESS_CODES:
>>>>>>             emit(op)
   20:         elif op in ASSERT_CODES:
    4:             emit(op)
    4:             skip = _len(code); emit(0)
    4:             if av[0] >= 0:
    4:                 emit(0) # look ahead
                   else:
>>>>>>                 lo, hi = av[1].getwidth()
>>>>>>                 if lo > MAXCODE:
>>>>>>                     raise error("looks too much behind")
>>>>>>                 if lo != hi:
>>>>>>                     raise PatternError("look-behind requires fixed-width pattern")
>>>>>>                 emit(lo) # look behind
    4:             _compile(code, av[1], flags)
    4:             emit(SUCCESS)
    4:             code[skip] = _len(code) - skip
   16:         elif op is AT:
    7:             emit(op)
    7:             if flags & SRE_FLAG_MULTILINE:
>>>>>>                 av = AT_MULTILINE.get(av, av)
    7:             if flags & SRE_FLAG_LOCALE:
>>>>>>                 av = AT_LOCALE.get(av, av)
    7:             elif flags & SRE_FLAG_UNICODE:
    7:                 av = AT_UNICODE.get(av, av)
    7:             emit(av)
    9:         elif op is BRANCH:
    9:             emit(op)
    9:             tail = []
    9:             tailappend = tail.append
   29:             for av in av[1]:
   20:                 skip = _len(code); emit(0)
                       # _compile_info(code, av, flags)
   20:                 _compile(code, av, flags)
   20:                 emit(JUMP)
   20:                 tailappend(_len(code)); emit(0)
   20:                 code[skip] = _len(code) - skip
    9:             emit(FAILURE) # end of branch
   29:             for tail in tail:
   20:                 code[tail] = _len(code) - tail
>>>>>>         elif op is CATEGORY:
>>>>>>             emit(op)
>>>>>>             if flags & SRE_FLAG_LOCALE:
>>>>>>                 av = CH_LOCALE[av]
>>>>>>             elif flags & SRE_FLAG_UNICODE:
>>>>>>                 av = CH_UNICODE[av]
>>>>>>             emit(av)
>>>>>>         elif op is GROUPREF:
>>>>>>             if not flags & SRE_FLAG_IGNORECASE:
>>>>>>                 emit(op)
>>>>>>             elif flags & SRE_FLAG_LOCALE:
>>>>>>                 emit(GROUPREF_LOC_IGNORE)
>>>>>>             elif not fixes:  # ascii
>>>>>>                 emit(GROUPREF_IGNORE)
                   else:
>>>>>>                 emit(GROUPREF_UNI_IGNORE)
>>>>>>             emit(av-1)
>>>>>>         elif op is GROUPREF_EXISTS:
>>>>>>             emit(op)
>>>>>>             emit(av[0]-1)
>>>>>>             skipyes = _len(code); emit(0)
>>>>>>             _compile(code, av[1], flags)
>>>>>>             if av[2]:
>>>>>>                 emit(JUMP)
>>>>>>                 skipno = _len(code); emit(0)
>>>>>>                 code[skipyes] = _len(code) - skipyes + 1
>>>>>>                 _compile(code, av[2], flags)
>>>>>>                 code[skipno] = _len(code) - skipno
                   else:
>>>>>>                 code[skipyes] = _len(code) - skipyes + 1
               else:
>>>>>>             raise PatternError(f"internal: unsupported operand type {op!r}")
       
>>>>>> def _compile_charset(charset, flags, code):
           # compile charset subprogram
   43:     emit = code.append
   94:     for op, av in charset:
   51:         emit(op)
   51:         if op is NEGATE:
    1:             pass
   50:         elif op is LITERAL:
   11:             emit(av)
   39:         elif op is RANGE or op is RANGE_UNI_IGNORE:
   10:             emit(av[0])
   10:             emit(av[1])
   29:         elif op is CHARSET:
    9:             code.extend(av)
   20:         elif op is BIGCHARSET:
    2:             code.extend(av)
   18:         elif op is CATEGORY:
   18:             if flags & SRE_FLAG_LOCALE:
>>>>>>                 emit(CH_LOCALE[av])
   18:             elif flags & SRE_FLAG_UNICODE:
   18:                 emit(CH_UNICODE[av])
                   else:
>>>>>>                 emit(av)
               else:
>>>>>>             raise PatternError(f"internal: unsupported set operator {op!r}")
   43:     emit(FAILURE)
       
>>>>>> def _optimize_charset(charset, iscased=None, fixup=None, fixes=None):
           # internal: optimize character set
   43:     out = []
   43:     tail = []
   43:     charmap = bytearray(256)
   43:     hascased = False
  149:     for op, av in charset:
  108:         while True:
  108:             try:
  108:                 if op is LITERAL:
   70:                     if fixup: # IGNORECASE and not LOCALE
   44:                         av = fixup(av)
   44:                         charmap[av] = 1
   44:                         if fixes and av in fixes:
    8:                             for k in fixes[av]:
    5:                                 charmap[k] = 1
   42:                         if not hascased and iscased(av):
    2:                             hascased = True
                           else:
   26:                         charmap[av] = 1
   38:                 elif op is RANGE:
   19:                     r = range(av[0], av[1]+1)
   19:                     if fixup: # IGNORECASE and not LOCALE
    6:                         if fixes:
>>>>>>                             for i in map(fixup, r):
>>>>>>                                 charmap[i] = 1
>>>>>>                                 if i in fixes:
>>>>>>                                     for k in fixes[i]:
>>>>>>                                         charmap[k] = 1
                               else:
  130:                             for i in map(fixup, r):
  124:                                 charmap[i] = 1
    6:                         if not hascased:
    4:                             hascased = any(map(iscased, r))
                           else:
  521:                         for i in r:
  508:                             charmap[i] = 1
   19:                 elif op is NEGATE:
    1:                     out.append((op, av))
                       else:
   18:                     tail.append((op, av))
    2:             except IndexError:
    2:                 if len(charmap) == 256:
                           # character set contains non-UCS1 character codes
    2:                     charmap += b'\0' * 0xff00
    2:                     continue
                       # Character set contains non-BMP character codes.
                       # For range, all BMP characters in the range are already
                       # proceeded.
>>>>>>                 if fixup: # IGNORECASE and not LOCALE
                           # For now, IN_UNI_IGNORE+LITERAL and
                           # IN_UNI_IGNORE+RANGE_UNI_IGNORE work for all non-BMP
                           # characters, because two characters (at least one of
                           # which is not in the BMP) match case-insensitively
                           # if and only if:
                           # 1) c1.lower() == c2.lower()
                           # 2) c1.lower() == c2 or c1.lower().upper() == c2
                           # Also, both c.lower() and c.lower().upper() are single
                           # characters for every non-BMP character.
>>>>>>                     if op is RANGE:
>>>>>>                         if fixes: # not ASCII
>>>>>>                             op = RANGE_UNI_IGNORE
>>>>>>                         hascased = True
                           else:
>>>>>>                         assert op is LITERAL
>>>>>>                         if not hascased and iscased(av):
>>>>>>                             hascased = True
>>>>>>                 tail.append((op, av))
  106:             break
       
           # compress character map
   43:     runs = []
   43:     q = 0
   84:     while True:
   84:         p = charmap.find(1, q)
   84:         if p < 0:
   30:             break
   54:         if len(runs) >= 2:
   11:             runs = None
   11:             break
   43:         q = charmap.find(0, p)
   43:         if q < 0:
    2:             runs.append((p, len(charmap)))
    2:             break
   41:         runs.append((p, q))
   43:     if runs is not None:
               # use literal/range
   53:         for p, q in runs:
   21:             if q - p == 1:
   11:                 out.append((LITERAL, p))
                   else:
   10:                 out.append((RANGE, (p, q - 1)))
   32:         out += tail
               # if the case was changed or new representation is more compact
   32:         if hascased or len(out) < len(charset):
    3:             return out, hascased
               # else original character set is good enough
   29:         return charset, hascased
       
           # use bitmap
   11:     if len(charmap) == 256:
    9:         data = _mk_bitmap(charmap)
    9:         out.append((CHARSET, data))
    9:         out += tail
    9:         return out, hascased
       
           # To represent a big charset, first a bitmap of all characters in the
           # set is constructed. Then, this bitmap is sliced into chunks of 256
           # characters, duplicate chunks are eliminated, and each chunk is
           # given a number. In the compiled expression, the charset is
           # represented by a 32-bit word sequence, consisting of one word for
           # the number of different chunks, a sequence of 256 bytes (64 words)
           # of chunk numbers indexed by their original chunk position, and a
           # sequence of 256-bit chunks (8 words each).
       
           # Compression is normally good: in a typical charset, large ranges of
           # Unicode will be either completely excluded (e.g. if only cyrillic
           # letters are to be matched), or completely included (e.g. if large
           # subranges of Kanji match). These ranges will be represented by
           # chunks of all one-bits or all zero-bits.
       
           # Matching can be also done efficiently: the more significant byte of
           # the Unicode character is an index into the chunk number, and the
           # less significant byte is a bit index in the chunk (just like the
           # CHARSET matching).
       
    2:     charmap = bytes(charmap) # should be hashable
    2:     comps = {}
    2:     mapping = bytearray(256)
    2:     block = 0
    2:     data = bytearray()
  514:     for i in range(0, 65536, 256):
  512:         chunk = charmap[i: i + 256]
  512:         if chunk in comps:
  506:             mapping[i // 256] = comps[chunk]
               else:
    6:             mapping[i // 256] = comps[chunk] = block
    6:             block += 1
    6:             data += chunk
    2:     data = _mk_bitmap(data)
    2:     data[0:0] = [block] + _bytes_to_codes(mapping)
    2:     out.append((BIGCHARSET, data))
    2:     out += tail
    2:     return out, hascased
       
>>>>>> _CODEBITS = _sre.CODESIZE * 8
>>>>>> MAXCODE = (1 << _CODEBITS) - 1
>>>>>> _BITS_TRANS = b'0' + b'1' * 255
>>>>>> def _mk_bitmap(bits, _CODEBITS=_CODEBITS, _int=int):
   11:     s = bits.translate(_BITS_TRANS)[::-1]
  142:     return [_int(s[i - _CODEBITS: i], 2)
  142:             for i in range(len(s), 0, -_CODEBITS)]
       
>>>>>> def _bytes_to_codes(b):
           # Convert block indices to word array
    2:     a = memoryview(b).cast('I')
    2:     assert a.itemsize == _sre.CODESIZE
    2:     assert len(a) * a.itemsize == len(b)
    2:     return a.tolist()
       
>>>>>> def _simple(p):
           # check if this subpattern is a "simple" operator
   45:     if len(p) != 1:
>>>>>>         return False
   45:     op, av = p[0]
   45:     if op is SUBPATTERN:
   12:         return av[0] is None and _simple(av[-1])
   33:     return op in _UNIT_CODES
       
>>>>>> def _generate_overlap_table(prefix):
           """
           Generate an overlap table for the following prefix.
           An overlap table is a table of the same size as the prefix which
           informs about the potential self-overlap for each index in the prefix:
           - if overlap[i] == 0, prefix[i:] can't overlap prefix[0:...]
           - if overlap[i] == k with 0 < k <= i, prefix[i-k+1:i+1] overlaps with
             prefix[0:k]
           """
    3:     table = [0] * len(prefix)
    8:     for i in range(1, len(prefix)):
    5:         idx = table[i - 1]
    6:         while prefix[i] != prefix[idx]:
    5:             if idx == 0:
    4:                 table[i] = 0
    4:                 break
    1:             idx = table[idx - 1]
               else:
    1:             table[i] = idx + 1
    3:     return table
       
>>>>>> def _get_iscased(flags):
   23:     if not flags & SRE_FLAG_IGNORECASE:
   21:         return None
    2:     elif flags & SRE_FLAG_UNICODE:
    2:         return _sre.unicode_iscased
           else:
>>>>>>         return _sre.ascii_iscased
       
>>>>>> def _get_literal_prefix(pattern, flags):
           # look for literal prefix
   15:     prefix = []
   15:     prefixappend = prefix.append
   15:     prefix_skip = None
   15:     iscased = _get_iscased(flags)
   23:     for op, av in pattern.data:
   23:         if op is LITERAL:
    8:             if iscased and iscased(av):
>>>>>>                 break
    8:             prefixappend(av)
   15:         elif op is SUBPATTERN:
    4:             group, add_flags, del_flags, p = av
    4:             flags1 = _combine_flags(flags, add_flags, del_flags)
    4:             if flags1 & SRE_FLAG_IGNORECASE and flags1 & SRE_FLAG_LOCALE:
>>>>>>                 break
    4:             prefix1, prefix_skip1, got_all = _get_literal_prefix(p, flags1)
    4:             if prefix_skip is None:
    4:                 if group is not None:
    3:                     prefix_skip = len(prefix)
    1:                 elif prefix_skip1 is not None:
>>>>>>                     prefix_skip = len(prefix) + prefix_skip1
    4:             prefix.extend(prefix1)
    4:             if not got_all:
    4:                 break
               else:
   11:             break
           else:
>>>>>>         return prefix, prefix_skip, True
   15:     return prefix, prefix_skip, False
       
>>>>>> def _get_charset_prefix(pattern, flags):
   11:     while True:
   11:         if not pattern.data:
>>>>>>             return None
   11:         op, av = pattern.data[0]
   11:         if op is not SUBPATTERN:
    8:             break
    3:         group, add_flags, del_flags, pattern = av
    3:         flags = _combine_flags(flags, add_flags, del_flags)
    3:         if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:
>>>>>>             return None
       
    8:     iscased = _get_iscased(flags)
    8:     if op is LITERAL:
>>>>>>         if iscased and iscased(av):
>>>>>>             return None
>>>>>>         return [(op, av)]
    8:     elif op is BRANCH:
    1:         charset = []
    1:         charsetappend = charset.append
    1:         for p in av[1]:
    1:             if not p:
>>>>>>                 return None
    1:             op, av = p[0]
    1:             if op is LITERAL and not (iscased and iscased(av)):
>>>>>>                 charsetappend((op, av))
                   else:
    1:                 return None
>>>>>>         return charset
    7:     elif op is IN:
    2:         charset = av
    2:         if iscased:
>>>>>>             for op, av in charset:
>>>>>>                 if op is LITERAL:
>>>>>>                     if iscased(av):
>>>>>>                         return None
>>>>>>                 elif op is RANGE:
>>>>>>                     if av[1] > 0xffff:
>>>>>>                         return None
>>>>>>                     if any(map(iscased, range(av[0], av[1]+1))):
>>>>>>                         return None
    2:         return charset
    5:     return None
       
>>>>>> def _compile_info(code, pattern, flags):
           # internal: compile an info block.  in the current version,
           # this contains min/max pattern width, and an optional literal
           # prefix or a character map
   13:     lo, hi = pattern.getwidth()
   13:     if hi > MAXCODE:
    9:         hi = MAXCODE
   13:     if lo == 0:
    2:         code.extend([INFO, 4, 0, lo, hi])
    2:         return
           # look for a literal prefix
   11:     prefix = []
   11:     prefix_skip = 0
   11:     charset = [] # not used
   11:     if not (flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE):
               # look for literal prefix
   11:         prefix, prefix_skip, got_all = _get_literal_prefix(pattern, flags)
               # if no prefix, look for charset prefix
   11:         if not prefix:
    8:             charset = _get_charset_prefix(pattern, flags)
       ##     if prefix:
       ##         print("*** PREFIX", prefix, prefix_skip)
       ##     if charset:
       ##         print("*** CHARSET", charset)
           # add an info block
   11:     emit = code.append
   11:     emit(INFO)
   11:     skip = len(code); emit(0)
           # literal flag
   11:     mask = 0
   11:     if prefix:
    3:         mask = SRE_INFO_PREFIX
    3:         if prefix_skip is None and got_all:
>>>>>>             mask = mask | SRE_INFO_LITERAL
    8:     elif charset:
    2:         mask = mask | SRE_INFO_CHARSET
   11:     emit(mask)
           # pattern length
   11:     if lo < MAXCODE:
   11:         emit(lo)
           else:
>>>>>>         emit(MAXCODE)
>>>>>>         prefix = prefix[:MAXCODE]
   11:     emit(hi)
           # add literal prefix
   11:     if prefix:
    3:         emit(len(prefix)) # length
    3:         if prefix_skip is None:
    3:             prefix_skip =  len(prefix)
    3:         emit(prefix_skip) # skip
    3:         code.extend(prefix)
               # generate overlap table
    3:         code.extend(_generate_overlap_table(prefix))
    8:     elif charset:
    2:         charset, hascased = _optimize_charset(charset)
    2:         assert not hascased
    2:         _compile_charset(charset, flags, code)
   11:     code[skip] = len(code) - skip
       
>>>>>> def isstring(obj):
   26:     return isinstance(obj, (str, bytes))
       
>>>>>> def _code(p, flags):
       
   13:     flags = p.state.flags | flags
   13:     code = []
       
           # compile info block
   13:     _compile_info(code, p, flags)
       
           # compile the pattern
   13:     _compile(code, p.data, flags)
       
   13:     code.append(SUCCESS)
       
   13:     return code
       
>>>>>> def _hex_code(code):
>>>>>>     return '[%s]' % ', '.join('%#0*x' % (_sre.CODESIZE*2+2, x) for x in code)
       
>>>>>> def dis(code):
>>>>>>     import sys
       
>>>>>>     labels = set()
>>>>>>     level = 0
>>>>>>     offset_width = len(str(len(code) - 1))
       
>>>>>>     def dis_(start, end):
>>>>>>         def print_(*args, to=None):
>>>>>>             if to is not None:
>>>>>>                 labels.add(to)
>>>>>>                 args += ('(to %d)' % (to,),)
>>>>>>             print('%*d%s ' % (offset_width, start, ':' if start in labels else '.'),
>>>>>>                   end='  '*(level-1))
>>>>>>             print(*args)
       
>>>>>>         def print_2(*args):
>>>>>>             print(end=' '*(offset_width + 2*level))
>>>>>>             print(*args)
       
               nonlocal level
>>>>>>         level += 1
>>>>>>         i = start
>>>>>>         while i < end:
>>>>>>             start = i
>>>>>>             op = code[i]
>>>>>>             i += 1
>>>>>>             op = OPCODES[op]
>>>>>>             if op in (SUCCESS, FAILURE, ANY, ANY_ALL,
>>>>>>                       MAX_UNTIL, MIN_UNTIL, NEGATE):
>>>>>>                 print_(op)
>>>>>>             elif op in (LITERAL, NOT_LITERAL,
>>>>>>                         LITERAL_IGNORE, NOT_LITERAL_IGNORE,
>>>>>>                         LITERAL_UNI_IGNORE, NOT_LITERAL_UNI_IGNORE,
>>>>>>                         LITERAL_LOC_IGNORE, NOT_LITERAL_LOC_IGNORE):
>>>>>>                 arg = code[i]
>>>>>>                 i += 1
>>>>>>                 print_(op, '%#02x (%r)' % (arg, chr(arg)))
>>>>>>             elif op is AT:
>>>>>>                 arg = code[i]
>>>>>>                 i += 1
>>>>>>                 arg = str(ATCODES[arg])
>>>>>>                 assert arg[:3] == 'AT_'
>>>>>>                 print_(op, arg[3:])
>>>>>>             elif op is CATEGORY:
>>>>>>                 arg = code[i]
>>>>>>                 i += 1
>>>>>>                 arg = str(CHCODES[arg])
>>>>>>                 assert arg[:9] == 'CATEGORY_'
>>>>>>                 print_(op, arg[9:])
>>>>>>             elif op in (IN, IN_IGNORE, IN_UNI_IGNORE, IN_LOC_IGNORE):
>>>>>>                 skip = code[i]
>>>>>>                 print_(op, skip, to=i+skip)
>>>>>>                 dis_(i+1, i+skip)
>>>>>>                 i += skip
>>>>>>             elif op in (RANGE, RANGE_UNI_IGNORE):
>>>>>>                 lo, hi = code[i: i+2]
>>>>>>                 i += 2
>>>>>>                 print_(op, '%#02x %#02x (%r-%r)' % (lo, hi, chr(lo), chr(hi)))
>>>>>>             elif op is CHARSET:
>>>>>>                 print_(op, _hex_code(code[i: i + 256//_CODEBITS]))
>>>>>>                 i += 256//_CODEBITS
>>>>>>             elif op is BIGCHARSET:
>>>>>>                 arg = code[i]
>>>>>>                 i += 1
>>>>>>                 mapping = list(b''.join(x.to_bytes(_sre.CODESIZE, sys.byteorder)
>>>>>>                                         for x in code[i: i + 256//_sre.CODESIZE]))
>>>>>>                 print_(op, arg, mapping)
>>>>>>                 i += 256//_sre.CODESIZE
>>>>>>                 level += 1
>>>>>>                 for j in range(arg):
>>>>>>                     print_2(_hex_code(code[i: i + 256//_CODEBITS]))
>>>>>>                     i += 256//_CODEBITS
>>>>>>                 level -= 1
>>>>>>             elif op in (MARK, GROUPREF, GROUPREF_IGNORE, GROUPREF_UNI_IGNORE,
>>>>>>                         GROUPREF_LOC_IGNORE):
>>>>>>                 arg = code[i]
>>>>>>                 i += 1
>>>>>>                 print_(op, arg)
>>>>>>             elif op is JUMP:
>>>>>>                 skip = code[i]
>>>>>>                 print_(op, skip, to=i+skip)
>>>>>>                 i += 1
>>>>>>             elif op is BRANCH:
>>>>>>                 skip = code[i]
>>>>>>                 print_(op, skip, to=i+skip)
>>>>>>                 while skip:
>>>>>>                     dis_(i+1, i+skip)
>>>>>>                     i += skip
>>>>>>                     start = i
>>>>>>                     skip = code[i]
>>>>>>                     if skip:
>>>>>>                         print_('branch', skip, to=i+skip)
                           else:
>>>>>>                         print_(FAILURE)
>>>>>>                 i += 1
>>>>>>             elif op in (REPEAT, REPEAT_ONE, MIN_REPEAT_ONE,
>>>>>>                         POSSESSIVE_REPEAT, POSSESSIVE_REPEAT_ONE):
>>>>>>                 skip, min, max = code[i: i+3]
>>>>>>                 if max == MAXREPEAT:
>>>>>>                     max = 'MAXREPEAT'
>>>>>>                 print_(op, skip, min, max, to=i+skip)
>>>>>>                 dis_(i+3, i+skip)
>>>>>>                 i += skip
>>>>>>             elif op is GROUPREF_EXISTS:
>>>>>>                 arg, skip = code[i: i+2]
>>>>>>                 print_(op, arg, skip, to=i+skip)
>>>>>>                 i += 2
>>>>>>             elif op in (ASSERT, ASSERT_NOT):
>>>>>>                 skip, arg = code[i: i+2]
>>>>>>                 print_(op, skip, arg, to=i+skip)
>>>>>>                 dis_(i+2, i+skip)
>>>>>>                 i += skip
>>>>>>             elif op is ATOMIC_GROUP:
>>>>>>                 skip = code[i]
>>>>>>                 print_(op, skip, to=i+skip)
>>>>>>                 dis_(i+1, i+skip)
>>>>>>                 i += skip
>>>>>>             elif op is INFO:
>>>>>>                 skip, flags, min, max = code[i: i+4]
>>>>>>                 if max == MAXREPEAT:
>>>>>>                     max = 'MAXREPEAT'
>>>>>>                 print_(op, skip, bin(flags), min, max, to=i+skip)
>>>>>>                 start = i+4
>>>>>>                 if flags & SRE_INFO_PREFIX:
>>>>>>                     prefix_len, prefix_skip = code[i+4: i+6]
>>>>>>                     print_2('  prefix_skip', prefix_skip)
>>>>>>                     start = i + 6
>>>>>>                     prefix = code[start: start+prefix_len]
>>>>>>                     print_2('  prefix',
>>>>>>                             '[%s]' % ', '.join('%#02x' % x for x in prefix),
>>>>>>                             '(%r)' % ''.join(map(chr, prefix)))
>>>>>>                     start += prefix_len
>>>>>>                     print_2('  overlap', code[start: start+prefix_len])
>>>>>>                     start += prefix_len
>>>>>>                 if flags & SRE_INFO_CHARSET:
>>>>>>                     level += 1
>>>>>>                     print_2('in')
>>>>>>                     dis_(start, i+skip)
>>>>>>                     level -= 1
>>>>>>                 i += skip
                   else:
>>>>>>                 raise ValueError(op)
       
>>>>>>         level -= 1
       
>>>>>>     dis_(0, len(code))
       
       
>>>>>> def compile(p, flags=0):
           # internal: convert pattern list to internal format
       
   13:     if isstring(p):
   13:         pattern = p
   13:         p = _parser.parse(p, flags)
           else:
>>>>>>         pattern = None
       
   13:     code = _code(p, flags)
       
   13:     if flags & SRE_FLAG_DEBUG:
>>>>>>         print()
>>>>>>         dis(code)
       
           # map in either direction
   13:     groupindex = p.state.groupdict
   13:     indexgroup = [None] * p.state.groups
   20:     for k, i in groupindex.items():
    7:         indexgroup[i] = k
       
   26:     return _sre.compile(
   13:         pattern, flags | p.state.flags, code,
   13:         p.state.groups-1,
   13:         groupindex, tuple(indexgroup)
               )
