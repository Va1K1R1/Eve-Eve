    1: """Unittest main program"""
       
    1: import sys
    1: import argparse
    1: import os
       
    1: from . import loader, runner
    1: from .signals import installHandler
       
    1: __unittest = True
    1: _NO_TESTS_EXITCODE = 5
       
    1: MAIN_EXAMPLES = """\
       Examples:
         %(prog)s test_module               - run tests from test_module
         %(prog)s module.TestClass          - run tests from module.TestClass
         %(prog)s module.Class.test_method  - run specified test method
         %(prog)s path/to/test_file.py      - run tests from test_file.py
       """
       
    1: MODULE_EXAMPLES = """\
       Examples:
         %(prog)s                           - run default set of tests
         %(prog)s MyTestSuite               - run suite 'MyTestSuite'
         %(prog)s MyTestCase.testSomething  - run MyTestCase.testSomething
         %(prog)s MyTestCase                - run all 'test*' test methods
                                              in MyTestCase
       """
       
    1: def _convert_name(name):
           # on Linux / Mac OS X 'foo.PY' is not importable, but on
           # Windows it is. Simpler to do a case insensitive match
           # a better check would be to check that the name is a
           # valid Python module name.
           if os.path.isfile(name) and name.lower().endswith('.py'):
               if os.path.isabs(name):
                   rel_path = os.path.relpath(name, os.getcwd())
                   if os.path.isabs(rel_path) or rel_path.startswith(os.pardir):
                       return name
                   name = rel_path
               # on Windows both '\' and '/' are used as path
               # separators. Better to replace both than rely on os.path.sep
               return os.path.normpath(name)[:-3].replace('\\', '.').replace('/', '.')
           return name
       
    1: def _convert_names(names):
           return [_convert_name(name) for name in names]
       
       
    1: def _convert_select_pattern(pattern):
           if not '*' in pattern:
               pattern = '*%s*' % pattern
           return pattern
       
       
    2: class TestProgram(object):
    1:     """A command-line program that runs a set of tests; this is primarily
              for making test modules conveniently executable.
           """
           # defaults for testing
    1:     module=None
    1:     verbosity = 1
    1:     failfast = catchbreak = buffer = progName = warnings = testNamePatterns = None
    1:     _discovery_parser = None
       
    3:     def __init__(self, module='__main__', defaultTest=None, argv=None,
    1:                     testRunner=None, testLoader=loader.defaultTestLoader,
    1:                     exit=True, verbosity=1, failfast=None, catchbreak=None,
    2:                     buffer=None, warnings=None, *, tb_locals=False,
    1:                     durations=None):
    1:         if isinstance(module, str):
    1:             self.module = __import__(module)
    1:             for part in module.split('.')[1:]:
                       self.module = getattr(self.module, part)
               else:
                   self.module = module
    1:         if argv is None:
    1:             argv = sys.argv
       
    1:         self.exit = exit
    1:         self.failfast = failfast
    1:         self.catchbreak = catchbreak
    1:         self.verbosity = verbosity
    1:         self.buffer = buffer
    1:         self.tb_locals = tb_locals
    1:         self.durations = durations
    1:         if warnings is None and not sys.warnoptions:
                   # even if DeprecationWarnings are ignored by default
                   # print them anyway unless other warnings settings are
                   # specified by the warnings arg or the -W python flag
    1:             self.warnings = 'default'
               else:
                   # here self.warnings is set either to the value passed
                   # to the warnings args or to None.
                   # If the user didn't pass a value self.warnings will
                   # be None. This means that the behavior is unchanged
                   # and depends on the values passed to -W.
                   self.warnings = warnings
    1:         self.defaultTest = defaultTest
    1:         self.testRunner = testRunner
    1:         self.testLoader = testLoader
    1:         self.progName = os.path.basename(argv[0])
    1:         self.parseArgs(argv)
    1:         self.runTests()
       
    1:     def _print_help(self, *args, **kwargs):
               if self.module is None:
                   print(self._main_parser.format_help())
                   print(MAIN_EXAMPLES % {'prog': self.progName})
                   self._discovery_parser.print_help()
               else:
                   print(self._main_parser.format_help())
                   print(MODULE_EXAMPLES % {'prog': self.progName})
       
    1:     def parseArgs(self, argv):
    1:         self._initArgParsers()
    1:         if self.module is None:
                   if len(argv) > 1 and argv[1].lower() == 'discover':
                       self._do_discovery(argv[2:])
                       return
                   self._main_parser.parse_args(argv[1:], self)
                   if not self.tests:
                       # this allows "python -m unittest -v" to still work for
                       # test discovery.
                       self._do_discovery([])
                       return
               else:
    1:             self._main_parser.parse_args(argv[1:], self)
       
    1:         if self.tests:
                   self.testNames = _convert_names(self.tests)
                   if __name__ == '__main__':
                       # to support python -m unittest ...
                       self.module = None
    1:         elif self.defaultTest is None:
                   # createTests will load tests from self.module
    1:             self.testNames = None
               elif isinstance(self.defaultTest, str):
                   self.testNames = (self.defaultTest,)
               else:
                   self.testNames = list(self.defaultTest)
    1:         self.createTests()
       
    1:     def createTests(self, from_discovery=False, Loader=None):
    1:         if self.testNamePatterns:
                   self.testLoader.testNamePatterns = self.testNamePatterns
    1:         if from_discovery:
                   loader = self.testLoader if Loader is None else Loader()
                   self.test = loader.discover(self.start, self.pattern, self.top)
    1:         elif self.testNames is None:
    1:             self.test = self.testLoader.loadTestsFromModule(self.module)
               else:
                   self.test = self.testLoader.loadTestsFromNames(self.testNames,
                                                                  self.module)
       
    1:     def _initArgParsers(self):
    1:         parent_parser = self._getParentArgParser()
    1:         self._main_parser = self._getMainArgParser(parent_parser)
    1:         self._discovery_parser = self._getDiscoveryArgParser(parent_parser)
       
    1:     def _getParentArgParser(self):
    1:         parser = argparse.ArgumentParser(add_help=False)
       
    2:         parser.add_argument('-v', '--verbose', dest='verbosity',
    1:                             action='store_const', const=2,
    1:                             help='Verbose output')
    2:         parser.add_argument('-q', '--quiet', dest='verbosity',
    1:                             action='store_const', const=0,
    1:                             help='Quiet output')
    2:         parser.add_argument('--locals', dest='tb_locals',
    1:                             action='store_true',
    1:                             help='Show local variables in tracebacks')
    2:         parser.add_argument('--durations', dest='durations', type=int,
    1:                             default=None, metavar="N",
    1:                             help='Show the N slowest test cases (N=0 for all)')
    1:         if self.failfast is None:
    2:             parser.add_argument('-f', '--failfast', dest='failfast',
    1:                                 action='store_true',
    1:                                 help='Stop on first fail or error')
    1:             self.failfast = False
    1:         if self.catchbreak is None:
    2:             parser.add_argument('-c', '--catch', dest='catchbreak',
    1:                                 action='store_true',
    1:                                 help='Catch Ctrl-C and display results so far')
    1:             self.catchbreak = False
    1:         if self.buffer is None:
    2:             parser.add_argument('-b', '--buffer', dest='buffer',
    1:                                 action='store_true',
    1:                                 help='Buffer stdout and stderr during tests')
    1:             self.buffer = False
    1:         if self.testNamePatterns is None:
    2:             parser.add_argument('-k', dest='testNamePatterns',
    1:                                 action='append', type=_convert_select_pattern,
    1:                                 help='Only run tests which match the given substring')
    1:             self.testNamePatterns = []
       
    1:         return parser
       
    1:     def _getMainArgParser(self, parent):
    1:         parser = argparse.ArgumentParser(parents=[parent])
    1:         parser.prog = self.progName
    1:         parser.print_help = self._print_help
       
    2:         parser.add_argument('tests', nargs='*',
    1:                             help='a list of any number of test modules, '
                                   'classes and test methods.')
       
    1:         return parser
       
    1:     def _getDiscoveryArgParser(self, parent):
    1:         parser = argparse.ArgumentParser(parents=[parent])
    1:         parser.prog = '%s discover' % self.progName
    1:         parser.epilog = ('For test discovery all test modules must be '
                                'importable from the top level directory of the '
                                'project.')
       
    2:         parser.add_argument('-s', '--start-directory', dest='start',
    1:                             help="Directory to start discovery ('.' default)")
    2:         parser.add_argument('-p', '--pattern', dest='pattern',
    1:                             help="Pattern to match tests ('test*.py' default)")
    2:         parser.add_argument('-t', '--top-level-directory', dest='top',
    1:                             help='Top level directory of project (defaults to '
                                        'start directory)')
    4:         for arg in ('start', 'pattern', 'top'):
    6:             parser.add_argument(arg, nargs='?',
    3:                                 default=argparse.SUPPRESS,
    3:                                 help=argparse.SUPPRESS)
       
    1:         return parser
       
    1:     def _do_discovery(self, argv, Loader=None):
               self.start = '.'
               self.pattern = 'test*.py'
               self.top = None
               if argv is not None:
                   # handle command line args for test discovery
                   if self._discovery_parser is None:
                       # for testing
                       self._initArgParsers()
                   self._discovery_parser.parse_args(argv, self)
       
               self.createTests(from_discovery=True, Loader=Loader)
       
    1:     def runTests(self):
    1:         if self.catchbreak:
                   installHandler()
    1:         if self.testRunner is None:
    1:             self.testRunner = runner.TextTestRunner
    1:         if isinstance(self.testRunner, type):
    1:             try:
    1:                 try:
    2:                     testRunner = self.testRunner(verbosity=self.verbosity,
    1:                                                  failfast=self.failfast,
    1:                                                  buffer=self.buffer,
    1:                                                  warnings=self.warnings,
    1:                                                  tb_locals=self.tb_locals,
    1:                                                  durations=self.durations)
                       except TypeError:
                           # didn't accept the tb_locals or durations argument
                           testRunner = self.testRunner(verbosity=self.verbosity,
                                                        failfast=self.failfast,
                                                        buffer=self.buffer,
                                                        warnings=self.warnings)
                   except TypeError:
                       # didn't accept the verbosity, buffer or failfast arguments
                       testRunner = self.testRunner()
               else:
                   # it is assumed to be a TestRunner instance
                   testRunner = self.testRunner
    1:         self.result = testRunner.run(self.test)
    1:         if self.exit:
    1:             if self.result.testsRun == 0 and len(self.result.skipped) == 0:
    1:                 sys.exit(_NO_TESTS_EXITCODE)
                   elif self.result.wasSuccessful():
                       sys.exit(0)
                   else:
                       sys.exit(1)
       
       
    1: main = TestProgram
