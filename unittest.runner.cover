       """Running tests"""
       
>>>>>> import sys
>>>>>> import time
>>>>>> import warnings
       
>>>>>> from . import result
>>>>>> from .case import _SubTest
>>>>>> from .signals import registerResult
       
>>>>>> __unittest = True
       
       
>>>>>> class _WritelnDecorator(object):
           """Used to decorate file-like objects with a handy 'writeln' method"""
>>>>>>     def __init__(self,stream):
    1:         self.stream = stream
       
>>>>>>     def __getattr__(self, attr):
  142:         if attr in ('stream', '__getstate__'):
>>>>>>             raise AttributeError(attr)
  142:         return getattr(self.stream,attr)
       
>>>>>>     def writeln(self, arg=None):
   26:         if arg:
   24:             self.write(arg)
   26:         self.write('\n') # text-mode streams translate to \r\n if needed
       
       
>>>>>> class TextTestResult(result.TestResult):
           """A test result class that can print formatted text results to a stream.
       
           Used by TextTestRunner.
           """
>>>>>>     separator1 = '=' * 70
>>>>>>     separator2 = '-' * 70
       
>>>>>>     def __init__(self, stream, descriptions, verbosity, *, durations=None):
               """Construct a TextTestResult. Subclasses should accept **kwargs
               to ensure compatibility as the interface changes."""
    1:         super(TextTestResult, self).__init__(stream, descriptions, verbosity)
    1:         self.stream = stream
    1:         self.showAll = verbosity > 1
    1:         self.dots = verbosity == 1
    1:         self.descriptions = descriptions
    1:         self._newline = True
    1:         self.durations = durations
       
>>>>>>     def getDescription(self, test):
   22:         doc_first_line = test.shortDescription()
   22:         if self.descriptions and doc_first_line:
    2:             return '\n'.join((str(test), doc_first_line))
               else:
   20:             return str(test)
       
>>>>>>     def startTest(self, test):
   22:         super(TextTestResult, self).startTest(test)
   22:         if self.showAll:
   22:             self.stream.write(self.getDescription(test))
   22:             self.stream.write(" ... ")
   22:             self.stream.flush()
   22:             self._newline = False
       
>>>>>>     def _write_status(self, test, status):
   22:         is_subtest = isinstance(test, _SubTest)
   22:         if is_subtest or self._newline:
>>>>>>             if not self._newline:
>>>>>>                 self.stream.writeln()
>>>>>>             if is_subtest:
>>>>>>                 self.stream.write("  ")
>>>>>>             self.stream.write(self.getDescription(test))
>>>>>>             self.stream.write(" ... ")
   22:         self.stream.writeln(status)
   22:         self.stream.flush()
   22:         self._newline = True
       
>>>>>>     def addSubTest(self, test, subtest, err):
>>>>>>         if err is not None:
>>>>>>             if self.showAll:
>>>>>>                 if issubclass(err[0], subtest.failureException):
>>>>>>                     self._write_status(subtest, "FAIL")
                       else:
>>>>>>                     self._write_status(subtest, "ERROR")
>>>>>>             elif self.dots:
>>>>>>                 if issubclass(err[0], subtest.failureException):
>>>>>>                     self.stream.write('F')
                       else:
>>>>>>                     self.stream.write('E')
>>>>>>                 self.stream.flush()
>>>>>>         super(TextTestResult, self).addSubTest(test, subtest, err)
       
>>>>>>     def addSuccess(self, test):
   22:         super(TextTestResult, self).addSuccess(test)
   22:         if self.showAll:
   22:             self._write_status(test, "ok")
>>>>>>         elif self.dots:
>>>>>>             self.stream.write('.')
>>>>>>             self.stream.flush()
       
>>>>>>     def addError(self, test, err):
>>>>>>         super(TextTestResult, self).addError(test, err)
>>>>>>         if self.showAll:
>>>>>>             self._write_status(test, "ERROR")
>>>>>>         elif self.dots:
>>>>>>             self.stream.write('E')
>>>>>>             self.stream.flush()
       
>>>>>>     def addFailure(self, test, err):
>>>>>>         super(TextTestResult, self).addFailure(test, err)
>>>>>>         if self.showAll:
>>>>>>             self._write_status(test, "FAIL")
>>>>>>         elif self.dots:
>>>>>>             self.stream.write('F')
>>>>>>             self.stream.flush()
       
>>>>>>     def addSkip(self, test, reason):
>>>>>>         super(TextTestResult, self).addSkip(test, reason)
>>>>>>         if self.showAll:
>>>>>>             self._write_status(test, "skipped {0!r}".format(reason))
>>>>>>         elif self.dots:
>>>>>>             self.stream.write("s")
>>>>>>             self.stream.flush()
       
>>>>>>     def addExpectedFailure(self, test, err):
>>>>>>         super(TextTestResult, self).addExpectedFailure(test, err)
>>>>>>         if self.showAll:
>>>>>>             self.stream.writeln("expected failure")
>>>>>>             self.stream.flush()
>>>>>>         elif self.dots:
>>>>>>             self.stream.write("x")
>>>>>>             self.stream.flush()
       
>>>>>>     def addUnexpectedSuccess(self, test):
>>>>>>         super(TextTestResult, self).addUnexpectedSuccess(test)
>>>>>>         if self.showAll:
>>>>>>             self.stream.writeln("unexpected success")
>>>>>>             self.stream.flush()
>>>>>>         elif self.dots:
>>>>>>             self.stream.write("u")
>>>>>>             self.stream.flush()
       
>>>>>>     def printErrors(self):
    1:         if self.dots or self.showAll:
    1:             self.stream.writeln()
    1:             self.stream.flush()
    1:         self.printErrorList('ERROR', self.errors)
    1:         self.printErrorList('FAIL', self.failures)
    1:         unexpectedSuccesses = getattr(self, 'unexpectedSuccesses', ())
    1:         if unexpectedSuccesses:
>>>>>>             self.stream.writeln(self.separator1)
>>>>>>             for test in unexpectedSuccesses:
>>>>>>                 self.stream.writeln(f"UNEXPECTED SUCCESS: {self.getDescription(test)}")
>>>>>>             self.stream.flush()
       
>>>>>>     def printErrorList(self, flavour, errors):
    2:         for test, err in errors:
>>>>>>             self.stream.writeln(self.separator1)
>>>>>>             self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))
>>>>>>             self.stream.writeln(self.separator2)
>>>>>>             self.stream.writeln("%s" % err)
>>>>>>             self.stream.flush()
       
       
>>>>>> class TextTestRunner(object):
           """A test runner class that displays results in textual form.
       
           It prints out the names of tests as they are run, errors as they
           occur, and a summary of the results at the end of the test run.
           """
>>>>>>     resultclass = TextTestResult
       
>>>>>>     def __init__(self, stream=None, descriptions=True, verbosity=1,
>>>>>>                  failfast=False, buffer=False, resultclass=None, warnings=None,
>>>>>>                  *, tb_locals=False, durations=None):
               """Construct a TextTestRunner.
       
               Subclasses should accept **kwargs to ensure compatibility as the
               interface changes.
               """
    1:         if stream is None:
    1:             stream = sys.stderr
    1:         self.stream = _WritelnDecorator(stream)
    1:         self.descriptions = descriptions
    1:         self.verbosity = verbosity
    1:         self.failfast = failfast
    1:         self.buffer = buffer
    1:         self.tb_locals = tb_locals
    1:         self.durations = durations
    1:         self.warnings = warnings
    1:         if resultclass is not None:
>>>>>>             self.resultclass = resultclass
       
>>>>>>     def _makeResult(self):
    1:         try:
    2:             return self.resultclass(self.stream, self.descriptions,
    1:                                     self.verbosity, durations=self.durations)
>>>>>>         except TypeError:
                   # didn't accept the durations argument
>>>>>>             return self.resultclass(self.stream, self.descriptions,
>>>>>>                                     self.verbosity)
       
>>>>>>     def _printDurations(self, result):
>>>>>>         if not result.collectedDurations:
>>>>>>             return
>>>>>>         ls = sorted(result.collectedDurations, key=lambda x: x[1],
>>>>>>                     reverse=True)
>>>>>>         if self.durations > 0:
>>>>>>             ls = ls[:self.durations]
>>>>>>         self.stream.writeln("Slowest test durations")
>>>>>>         if hasattr(result, 'separator2'):
>>>>>>             self.stream.writeln(result.separator2)
>>>>>>         hidden = False
>>>>>>         for test, elapsed in ls:
>>>>>>             if self.verbosity < 2 and elapsed < 0.001:
>>>>>>                 hidden = True
>>>>>>                 continue
>>>>>>             self.stream.writeln("%-10s %s" % ("%.3fs" % elapsed, test))
>>>>>>         if hidden:
>>>>>>             self.stream.writeln("\n(durations < 0.001s were hidden; "
                                       "use -v to show these durations)")
               else:
>>>>>>             self.stream.writeln("")
       
>>>>>>     def run(self, test):
               "Run the given test case or test suite."
    1:         result = self._makeResult()
    1:         registerResult(result)
    1:         result.failfast = self.failfast
    1:         result.buffer = self.buffer
    1:         result.tb_locals = self.tb_locals
    2:         with warnings.catch_warnings():
    1:             if self.warnings:
                       # if self.warnings is set, use it to filter all the warnings
>>>>>>                 warnings.simplefilter(self.warnings)
    1:             startTime = time.perf_counter()
    1:             startTestRun = getattr(result, 'startTestRun', None)
    1:             if startTestRun is not None:
    1:                 startTestRun()
    1:             try:
    1:                 test(result)
                   finally:
    1:                 stopTestRun = getattr(result, 'stopTestRun', None)
    1:                 if stopTestRun is not None:
    1:                     stopTestRun()
    1:             stopTime = time.perf_counter()
    1:         timeTaken = stopTime - startTime
    1:         result.printErrors()
    1:         if self.durations is not None:
>>>>>>             self._printDurations(result)
       
    1:         if hasattr(result, 'separator2'):
    1:             self.stream.writeln(result.separator2)
       
    1:         run = result.testsRun
    2:         self.stream.writeln("Ran %d test%s in %.3fs" %
    1:                             (run, run != 1 and "s" or "", timeTaken))
    1:         self.stream.writeln()
       
    1:         expectedFails = unexpectedSuccesses = skipped = 0
    1:         try:
    2:             results = map(len, (result.expectedFailures,
    1:                                 result.unexpectedSuccesses,
    1:                                 result.skipped))
>>>>>>         except AttributeError:
>>>>>>             pass
               else:
    1:             expectedFails, unexpectedSuccesses, skipped = results
       
    1:         infos = []
    1:         if not result.wasSuccessful():
>>>>>>             self.stream.write("FAILED")
>>>>>>             failed, errored = len(result.failures), len(result.errors)
>>>>>>             if failed:
>>>>>>                 infos.append("failures=%d" % failed)
>>>>>>             if errored:
>>>>>>                 infos.append("errors=%d" % errored)
    1:         elif run == 0 and not skipped:
>>>>>>             self.stream.write("NO TESTS RAN")
               else:
    1:             self.stream.write("OK")
    1:         if skipped:
>>>>>>             infos.append("skipped=%d" % skipped)
    1:         if expectedFails:
>>>>>>             infos.append("expected failures=%d" % expectedFails)
    1:         if unexpectedSuccesses:
>>>>>>             infos.append("unexpected successes=%d" % unexpectedSuccesses)
    1:         if infos:
>>>>>>             self.stream.writeln(" (%s)" % (", ".join(infos),))
               else:
    1:             self.stream.write("\n")
    1:         self.stream.flush()
    1:         return result
