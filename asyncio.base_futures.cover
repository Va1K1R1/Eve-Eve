    1: __all__ = ()
       
    1: import reprlib
       
    1: from . import format_helpers
       
       # States for Future.
    1: _PENDING = 'PENDING'
    1: _CANCELLED = 'CANCELLED'
    1: _FINISHED = 'FINISHED'
       
       
    1: def isfuture(obj):
           """Check for a Future.
       
           This returns True when obj is a Future instance or is advertising
           itself as duck-type compatible by setting _asyncio_future_blocking.
           See comment in Future for more details.
           """
   68:     return (hasattr(obj.__class__, '_asyncio_future_blocking') and
   28:             obj._asyncio_future_blocking is not None)
       
       
    1: def _format_callbacks(cb):
           """helper function for Future.__repr__"""
>>>>>>     size = len(cb)
>>>>>>     if not size:
>>>>>>         cb = ''
       
>>>>>>     def format_cb(callback):
>>>>>>         return format_helpers._format_callback_source(callback, ())
       
>>>>>>     if size == 1:
>>>>>>         cb = format_cb(cb[0][0])
>>>>>>     elif size == 2:
>>>>>>         cb = '{}, {}'.format(format_cb(cb[0][0]), format_cb(cb[1][0]))
>>>>>>     elif size > 2:
>>>>>>         cb = '{}, <{} more>, {}'.format(format_cb(cb[0][0]),
>>>>>>                                         size - 2,
>>>>>>                                         format_cb(cb[-1][0]))
>>>>>>     return f'cb=[{cb}]'
       
       
    1: def _future_repr_info(future):
           # (Future) -> str
           """helper function for Future.__repr__"""
   40:     info = [future._state.lower()]
   40:     if future._state == _FINISHED:
   40:         if future._exception is not None:
>>>>>>             info.append(f'exception={future._exception!r}')
               else:
                   # use reprlib to limit the length of the output, especially
                   # for very long strings
   40:             result = reprlib.repr(future._result)
   40:             info.append(f'result={result}')
   40:     if future._callbacks:
>>>>>>         info.append(_format_callbacks(future._callbacks))
   40:     if future._source_traceback:
   40:         frame = future._source_traceback[-1]
   40:         info.append(f'created at {frame[0]}:{frame[1]}')
   40:     return info
       
       
    2: @reprlib.recursive_repr()
    2: def _future_repr(future):
   40:     info = ' '.join(_future_repr_info(future))
   40:     return f'<{future.__class__.__name__} {info}>'
