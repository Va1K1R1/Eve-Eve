    1: import asyncio
    1: import contextvars
    1: import inspect
    1: import warnings
       
    1: from .case import TestCase
       
    1: __unittest = True
       
    2: class IsolatedAsyncioTestCase(TestCase):
           # Names intentionally have a long prefix
           # to reduce a chance of clashing with user-defined attributes
           # from inherited test case
           #
           # The class doesn't call loop.run_until_complete(self.setUp()) and family
           # but uses a different approach:
           # 1. create a long-running task that reads self.setUp()
           #    awaitable from queue along with a future
           # 2. await the awaitable object passing in and set the result
           #    into the future object
           # 3. Outer code puts the awaitable and the future object into a queue
           #    with waiting for the future
           # The trick is necessary because every run_until_complete() call
           # creates a new task with embedded ContextVar context.
           # To share contextvars between setUp(), test and tearDown() we need to execute
           # them inside the same task.
       
           # Note: the test case modifies event loop policy if the policy was not instantiated
           # yet, unless loop_factory=asyncio.EventLoop is set.
           # asyncio.get_event_loop_policy() creates a default policy on demand but never
           # returns None
           # I believe this is not an issue in user level tests but python itself for testing
           # should reset a policy in every test module
           # by calling asyncio.set_event_loop_policy(None) in tearDownModule()
           # or set loop_factory=asyncio.EventLoop
       
    1:     loop_factory = None
       
    1:     def __init__(self, methodName='runTest'):
    3:         super().__init__(methodName)
    3:         self._asyncioRunner = None
    3:         self._asyncioTestContext = contextvars.copy_context()
       
    1:     async def asyncSetUp(self):
    3:         pass
       
    1:     async def asyncTearDown(self):
    3:         pass
       
    1:     def addAsyncCleanup(self, func, /, *args, **kwargs):
               # A trivial trampoline to addCleanup()
               # the function exists because it has a different semantics
               # and signature:
               # addCleanup() accepts regular functions
               # but addAsyncCleanup() accepts coroutines
               #
               # We intentionally don't add inspect.iscoroutinefunction() check
               # for func argument because there is no way
               # to check for async function reliably:
               # 1. It can be "async def func()" itself
               # 2. Class can implement "async def __call__()" method
               # 3. Regular "def func()" that returns awaitable object
>>>>>>         self.addCleanup(*(func, *args), **kwargs)
       
    1:     async def enterAsyncContext(self, cm):
               """Enters the supplied asynchronous context manager.
       
               If successful, also adds its __aexit__ method as a cleanup
               function and returns the result of the __aenter__ method.
               """
               # We look up the special methods on the type to match the with
               # statement.
>>>>>>         cls = type(cm)
>>>>>>         try:
>>>>>>             enter = cls.__aenter__
>>>>>>             exit = cls.__aexit__
>>>>>>         except AttributeError:
>>>>>>             raise TypeError(f"'{cls.__module__}.{cls.__qualname__}' object does "
                                   f"not support the asynchronous context manager protocol"
>>>>>>                            ) from None
>>>>>>         result = await enter(cm)
>>>>>>         self.addAsyncCleanup(exit, cm, None, None, None)
>>>>>>         return result
       
    1:     def _callSetUp(self):
               # Force loop to be initialized and set as the current loop
               # so that setUp functions can use get_event_loop() and get the
               # correct loop instance.
    3:         self._asyncioRunner.get_loop()
    3:         self._asyncioTestContext.run(self.setUp)
    3:         self._callAsync(self.asyncSetUp)
       
    1:     def _callTestMethod(self, method):
    3:         if self._callMaybeAsync(method) is not None:
>>>>>>             warnings.warn(f'It is deprecated to return a value that is not None from a '
>>>>>>                           f'test case ({method})', DeprecationWarning, stacklevel=4)
       
    1:     def _callTearDown(self):
    3:         self._callAsync(self.asyncTearDown)
    3:         self._asyncioTestContext.run(self.tearDown)
       
    1:     def _callCleanup(self, function, *args, **kwargs):
>>>>>>         self._callMaybeAsync(function, *args, **kwargs)
       
    1:     def _callAsync(self, func, /, *args, **kwargs):
    6:         assert self._asyncioRunner is not None, 'asyncio runner is not initialized'
    6:         assert inspect.iscoroutinefunction(func), f'{func!r} is not an async function'
   12:         return self._asyncioRunner.run(
    6:             func(*args, **kwargs),
    6:             context=self._asyncioTestContext
               )
       
    1:     def _callMaybeAsync(self, func, /, *args, **kwargs):
    3:         assert self._asyncioRunner is not None, 'asyncio runner is not initialized'
    3:         if inspect.iscoroutinefunction(func):
    6:             return self._asyncioRunner.run(
    3:                 func(*args, **kwargs),
    3:                 context=self._asyncioTestContext,
                   )
               else:
>>>>>>             return self._asyncioTestContext.run(func, *args, **kwargs)
       
    1:     def _setupAsyncioRunner(self):
    3:         assert self._asyncioRunner is None, 'asyncio runner is already initialized'
    3:         runner = asyncio.Runner(debug=True, loop_factory=self.loop_factory)
    3:         self._asyncioRunner = runner
       
    1:     def _tearDownAsyncioRunner(self):
    6:         runner = self._asyncioRunner
    6:         runner.close()
       
    1:     def run(self, result=None):
    3:         self._setupAsyncioRunner()
    3:         try:
    3:             return super().run(result)
               finally:
    3:             self._tearDownAsyncioRunner()
       
    1:     def debug(self):
>>>>>>         self._setupAsyncioRunner()
>>>>>>         super().debug()
>>>>>>         self._tearDownAsyncioRunner()
       
    1:     def __del__(self):
    3:         if self._asyncioRunner is not None:
    3:             self._tearDownAsyncioRunner()
